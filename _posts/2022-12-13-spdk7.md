---
title:  "Userspace I/O(UIO)"
excerpt: "Anatomy of SPDK/NVMe Storage Technology #7"

toc: true
toc_sticky: true

categories:
  - NVMe Storage Technology
tags:
  - SPDK
  - UIO
---

<br>

# Userspace I/O(UIO)

UIO(Userspace I/O)는 사용자 공간에서 실행되는 I/O 기술입니다. Linux 시스템에서 일반 장치 드라이버는 커널 공간에서 실행되며 사용자 공간에서 응용 프로그램에 의해 호출될 수 있습니다. 그리고 **UIO는 커널 공간에서 장치 드라이버의 작은 부분을 실행하고 사용자 공간에서 드라이버의 대부분의 기능을 구현**합니다. 그런 다음 커널 공간 UIO에서 수행할 작업은 두 가지 유형으로 나누어 매우 간단해집니다.

1. **장치에 필요한 리소스 할당 및 기록 및 UIO 장치 등록**
2. **커널 공간에서 구현해야 하는 인터럽트 처리기 구현**

![img](/assets/images/spdk7-1.png)

<br>

Linux 시스템에서 UIO 드라이버의 위치를 이해한 후, UIO에 대한 이해를 심화하기 위해 일부 참조 자료([Linux User Space Device Drivers](http://blog.idv-tech.com/wp-content/uploads/2014/09/drivers-session3-uio-4public.pdf))를 정리하였습니다.

## 1. Device Driver Architectures

- Linux 장치 드라이버는 일반적으로 커널 공간에서 실행되는 커널 드라이버로 설계되었습니다.
- 사용자 공간 I/O는 Linux 커널 2.6.24 이후로 지원되는 또 다른 대체 장치 드라이버 아키텍처입니다.
- Linux 커널 커뮤니티의 사람들은 사용자 공간 I /O의 필요성에 항상 동의하지 않을 수 있습니다.
- 산업용 I/O 카드는 오랫동안 사용자 공간 I/O를 활용해 왔습니다.
- 일부 유형의 장치에서는 Linux 커널 드라이버를 만드는 것이 과도 할 수 있습니다.
- FPGA의 Soft IP에는 고유한 요구 사항이 있으며 드라이버로 구현함에 있어 항상 적합한 것은 아닙니다.



## 2. Legacy User Space Driver Methods (/dev/mem)

- 장치 메모리를 사용자 공간에 매핑하는 /dev/mem이라는 문자 드라이버가 커널에 존재합니다.
- 이 드라이버를 사용하면 사용자 공간 응용 프로그램이 장치 메모리에 액세스할 수 있습니다.
- 이는 큰 보안 허점이기 때문에 커널 구성에서 메모리 액세스를 비 활성화할 수 있습니다(CONFIG_STRICT_DEVMEM).

- 루트 사용자여야 합니다.
- 새 하드웨어의 프로토타이핑 또는 테스트를 위한 훌륭한 도구이지만, 사용자 공간 장치 드라이버에 적합한 프로덕션 솔루션으로 간주되지 않습니다.
- 모든 주소를 사용자 공간에 매핑할 수 있기 때문에 버그가 있는 사용자 공간 드라이버가 커널을 중단시킬 수 있습니다.



## 3. Introduction to UIO

- Linux 커널은 UIO라는 사용자 공간 드라이버를 수행하기 위한 프레임워크를 제공합니다.

- 프레임워크는 사용자 공간 드라이버 아래 계층으로 실행되는 문자 모드 커널 드라이버(drivers/uio)입니다.
- UIO는 드라이버 개발 작업의 일부를 오프로드 하는데 도움이 됩니다.
- UIO의 "U"는 Universal이 아닙니다.
  - 커널 프레임워크에서 잘 처리되는 장치는 이상적으로는 커널에 있어야 합니다(많은 커널 개발자에게 묻는 경우).
  - 네트워킹은 반도체 공급업체가 향상된 성능을 얻기 위해 사용자 공간 I/O를 수행하는 영역 중 하나입니다.
- UIO는 간단한 장치 드라이버를 정말 잘 처리합니다.
  - 간단한 드라이버: 커널 프레임워크에 액세스할 필요 없는 장치 액세스 및 인터럽트 처리



## 4. Kernel Space Driver Characteristics

### 4.1 Advantages

- 인터럽트 및 하드웨어 리소스에 대한 액세스를 허용하기 위해 최고 권한 모드로 커널 공간에서 실행됩니다.
- 커널 공간 드라이버가 복잡한 장치용으로 설계될 수 있는 커널 서비스가 많이 있습니다.
- 커널은 여러 응용 프로그램이 커널 공간 드라이버에 동시에 액세스할 수 있도록 사용자 공간에 API를 제공합니다.
  - 더 크고 확장 가능한 소프트웨어 시스템을 설계할 수 있습니다.
- 많은 드라이버가 커널 공간인 경향이 있습니다.
  - 오픈 소스 커뮤니티에서 질문하기가 더 유리합니다.
  - 드라이버를 오픈 소스 커뮤니티로 쉽게 푸시할 수 있습니다.

### 4.2 Disadvantages

- 드라이버 액세스를 위한 시스템 호출 오버헤드
  - 사용자 공간에서 커널 공간으로(또는 그 반대로) 전환이 필요합니다.
  - 실시간 애플리케이션에 영향을 미치는 오버헤드가 비 결정적입니다.


- 학습의 어려움
  - 커널 API는 응용 프로그램 수준 API와 달라 생산성이 높아지는데 시간이 걸립니다.
- 버그는 커널 중단을 일으켜 치명적입니다.
- 디버깅의 어려움
  - 커널 코드는 고도로 최적화되어 있으며 다양한 디버그 도구가 있습니다.
- 빈번한 커널 API 변경
  - 어떤 커널 버전용으로 빌드된 커널 드라이버가 다른 버전용으로 빌드되지 않을 수 있습니다.



## 5. User Space Device Driver Characteristics

### 5.1 Advantages

- Less challenging to debug as debug tools are more readily available and common to normal application development
- User space services such as floating point are available
- Device access is very efficient as there is no system call required
- The application API of Linux is very stable
- The driver can be written in any language, not just "C"

### 5.2 Disadvantages

- No access to the kernel frameworks and services
  - \- Contiguous memory allocation, direct cache control, and DMA are not available
  - \- May have to duplicate kernel code or use a kernel driver to supplement
- Interrupt handling cannot be done in user space
  - \- It must be handled by a kernel driver which notifies user space causing some delay
- There is no predefined API to allow applications to access the device driver
  - \- Concurrency must also be considered if multiple applications access a driver



## 6. UIO Framework Features

- There are two distinct UIO device drivers provided by Linux in drivers/uio
- UIO Driver (drivers/uio.c)
  - \- For more advanced users as a minimal kernel space driver is required to setup the UIO framework
  - \- This is the most universal and likely to handle all situations since the kernel space driver can be very custom
  - \- The majority of work can be accomplished in the user space driver
- UIO Platform Device Driver (drivers/uio_pdev_irqgen.c)
  - This driver augments the UIO driver such that no kernel space driver is required
    - It provides the required kernel space driver for uio
  - It works with device tree making it easy to use
    - The device tree node for the device needs to use "generic uio" in it's compatible
  - Best starting point since no kernel space code is needed



## 7. UIO Driver Kernel Configuration

- UIO drivers must be configured in the Linux kernel

```bash
CONFIG_UIO=y
CONFIG_UIO_PDRV_GENIRQ=y
```



## 8. UIO Platform Device Driver Details

- The user provides only a user space driver
- The UIO platform device driver configures from the device tree and registers a UIO device
- The user space driver has direct access to the hardware
- The user space driver gets notified of an interrupt by reading the UIO device file descriptor

![img](/assets/images/spdk7-2.png)



## 9. Kernel UIO API - Sys Filesystem

- The UIO driver in the kernel creates file attributes in the sys filesystem describing the UIO device
- /sys/class/uio is the root directory for all the file attributes
- A separate numbered directory structure is created under /sys/class/uio for each UIO device
  - \- First UIO device: /sys/class/uio/uio0
  - \- /sys/class/uio/uio0/name contains the name of the device which correlates to the name in the uio_info structure
  - \- /sys/class/uio/uio0/maps is a directory that has all the memory ranges for the device
  - \- Each numbered map directory has attributes to describe the device memory including the address, name, offset and size
    -  /sys/class/uio/uio0/maps/map0



## 10. User Space Driver Flow

- 01 - The kernel space UIO device driver(s) must be loaded before the user space driver is started (if using modules)
- 02 - The user space application is started and the UIO device file is opened (/dev/uioX where X is 0, 1, 2 ...)
  - \- From user space, the UIO device is a device node in the file system just like any other device
- 03 - The device memory address information is found from the relevant sysfs directory, only the size is needed
- 04 - The device memory is mapped into the process address space by calling the mmap() function of the UIO driver
- 05 - The application accesses the device hardware to control the device
- 06 - The device memory is unmapped by calling munmap()
- 07 - The UIO device file is closed



## 11. User Space Driver Example

```c
 1 #define UIO_SIZE "/sys/class/uio/uio0/maps/map0/size"
 2 
 3 int main(int argc, char **argv)
 4 {
 5         int             uio_fd;
 6         unsigned int    uio_size;
 7         FILE            *size_fp;
 8         void            *base_address;
 9 
10         /*
11          * 1. Open the UIO device so that it is ready to use
12          */
13         uio_fd = open("/dev/uio0", O_RDWR);
14 
15         /*
16          * 2. Get the size of the memory region from the size sysfs file
17          *    attribute
18          */
19         size_fp = fopen(UIO_SIZE, O_RDONLY);
20         fscanf(size_fp, "0x%08X", &uio_size);
21 
22         /*
23          * 3. Map the device registers into the process address space so they
24          *    are directly accessible
25          */
26         base_address = mmap(NULL, uio_size,
27                            PROT_READ|PROT_WRITE,
28                            MAP_SHARED, uio_fd, 0);
29 
30         // Access to the hardware can now occur ...
31 
32         /*
33          * 4. Unmap the device registers to finish
34          */
35         munmap(base_address, uio_size);
36 
37         ...
38 }
```



## 12. Mapping Device Memory Details

- The character device driver framework of Linux provides the ability to map device memory into a user space process address space
- A character driver may implement the mmap() function which a user space application can call
- The mmap() function creates a new mapping in the virtual address space of the calling process
  - \- A virtual address, corresponding to the physical address specified is returned
  - \- It can also be used to map a file into a memory space such that the contents of the file are accessed by memory reads and writes
- Whenever the user space program reads or writes in the virtual address range it is accessing the device
- This provides improved performance as no system calls are required



## 13 Mapping Device Memory Flow

![img](/assets/images/spdk7-3.png)



## 14 User Space Application Interrupt Processing

- Interrupts are never handled directly in user space
- The interrupt can be handled by the UIO kernel driver which then relays it on to user space via the UIO device file descriptor
- The user space driver that wants to be notified when interrupts occur calls select() or read() on the UIO device file descriptor
  -  \- The read can be done as blocking or non-blocking mode
- read() returns the number of events (interrupts)
- A thread could be used to handle interrupts
- Alternatively a user provided kernel driver can handle the interrupt and then communicate data to the user space driver through other mechanisms like shared memory
  - \- This may be necessary for devices which have very fast interrupts



## 15. User Space Application Interrupt Processing Example

```c
 1 int pending = 0;
 2 int reenable = 1;
 3 
 4 /*
 5  * 1. The UIO device is opened as previously described
 6  */
 7 int uio_fd = open("/dev/uio0", O_RDWR);
 8 
 9 /*
10  * 2. Read the UIO device file descriptor to wait for an interrupt,
11  *    the read blocks by default, a non blocking read can also be used
12  *
13  *    NOTE: The pending variable contains the number of interrupts that have
14  *          occurred if multiple
15  */
16 read(uio_fd, (void *)&pending, sizeof(int));
17 
18 
19 //
20 // add device specific processing like acking the interrupt in the device here
21 //
22 
23 
24 /*
25  * 3. Re-enable the interrupt at the interrupt controller level
26  */
27 write(uio_fd, (void *)&reenable, sizeof(int));
```



 

**Part II: Advanced UIO With Both User Space Application and Kernel Space Driver**

## 16. UIO Driver Details

![img](/assets/images/spdk7-4.png)

- The user provides a kernel driver and a user space driver
- The kernel space driver is a platform driver configuring from the device tree and registering a UIO device
- The kernel space driver can also provide an interrupt handler in kernel space
- The user space driver has direct access to the hardware



## 17. Kernel UIO API - Basics

- The API is small and simple to use API小且易用

```c
struct uio_info
-- name      : device name
-- version   : device driver version
-- irq       : interrupt number
-- irq_flags : flags for request_irq()
-- handler   : driver irq handler (optional)
-- mem[]     : memory regions that can be mapped to user space
   o    addr : memory address
   o memtype : type of memory region (physical, logical, virtual)
```



## 18. Kernel UIO API - Registration

- The function uio_register_device() connects the driver to the UIO framework

  - Requires a struct uio_info as an input
- Typically called from the probe() function of a platform device driver
  - Creates device file /dev/uio# (#starting from 0) and all associated sysfs file attributes

- The function uio_unregister_device() disconnects the driver from the UIO framework

  - Typically called from the cleanup function of a platform device driver
  - Deletes the device file /dev/uio#



## 19. Kernel Space Driver Example

```c
 1 probe()
 2 {
 3     /*
 4      * 1. Platform device driver initialization in the driver probe() function
 5      */
 6     dev = devm_kzalloc(&pdev->dev, (sizeof(struct uio_timer_dev)), GFP_KERNEL);
 7     res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 8     dev->regs = devm_ioremap_resource(&pdev->dev, res);
 9     irq = platform_get_irq(pdev, 0);
10 
11     /*
12      * 2. Add basic UIO structure initialization
13      */
14     dev->uio_info.name = "uio_timer";
15     dev->uio_info.version = 1;
16     dev->uio_info.priv = dev;
17 
18     /*
19      * 3. Add the memory region initialization for the UIO
20      */
21     dev->uio_info.mem[0].name = "registers";
22     dev->uio_info.mem[0].addr = res->start;
23     dev->uio_info.mem[0].size = resource_size(res);
24     dev->uio_info.mem[0].memtype = UIO_MEM_PHYS;
25 
26     /*
27      * 4. Add the interrupt initialization for the UIO
28      */
29     dev->uio_info.irq = irq;
30     dev->uio_info.handler = uio_irq_handler;
31 
32     /*
33      * 5. Register the UIO device with the kernel framework
34      */
35     uio_register_device(&pdev->dev, &dev->info);
36 }
```



## 20. UIO Framework Details

- UIO Driver
  - \- The device tree node for the device can use whatever you want in the compatible property as it only has to match what is used in the kernel space driver as with any platform device driver
- UIO Platform Device Driver
  - \- The device tree node for the device needs to use "generic - uio" in it's compatible property

 

**참조 자료**

- [Linux User Space Device Drivers](http://blog.idv-tech.com/wp-content/uploads/2014/09/drivers-session3-uio-4public.pdf)
- [UIO: user-space drivers](https://lwn.net/Articles/232575/)
- [Howto: Accessing PCI devices from userspace](https://github.com/rumpkernel/wiki/wiki/Howto:-Accessing-PCI-devices-from-userspace)
- [Kernel space: the UIO interface for device drivers](https://www.networkworld.com/article/2299025/software/kernel-space--the-uio-interface-for-device-drivers.html)
- Paper: [Userspace I/O drivers in a realtime context](https://www.osadl.org/fileadmin/dam/rtlws/12/Koch.pdf)
