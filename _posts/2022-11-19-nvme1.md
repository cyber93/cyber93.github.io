---
title:  "NVMe Base Spec. Rev. 1.4c"
excerpt: "Chap 1, 2, 3, 4 정리"

toc: true
toc_sticky: true

categories:
  - NVMe
tags:
  - NVMe Spec
---

<br>

```
참고: http://ssu1945.egloos.com/4007260
설명: 기본적으로 사이트 원문을 참고하여 재구성 하였음.
```

# 시작에 앞서

## NVMe Spec. 구성

기초적인 PC 관련 지식이 있어야 합니다. NVMe Subsystem(간단히 SSD)의 목적 자체가 Data 저장장치이니 CPU - RAM - PCI bus - 노스브리지 - HBA - AHCI 정도 용어와 실제 PC의 Data 흐름을 알고 있으면 좋습니다.

1장은 간단한 소개들로 시작됩니다.

- 어떤 단어들을 사용하는지에 대한 간략한 설명과 컨셉에 대해 이야기 합니다.
- 가상화(SR-IOV)나 Namespace에 대한 내용은 그냥 읽고만 넘어가세요. 뒤에 더 자세히 나옵니다.

2장 System Bus (PCI Express) Registers라고 친절히 적혀 있네요.

- Protocol Layer만 있기 때문에 Link단 부터 이용되는 PCIe에 대한 이해는 필수입니다.
- Host(PC)가 NVMe Subsystem(간단히 SSD)를 인식하기 위한 PCI Header와 그 부분을 NVMe에서 어떻게 쓸지에 대해 이야기 합니다.

3장 Controller Registers. 말 그대로 입니다.

- NVMe Subsystem의 Controller에서 지원하는 기능들을 Host(PC)에 알려주기 위한 일종의 가이드 입니다.


4장 Data Structures

- NVMe는 직접 Host(PC) DRAM을 Access합니다. 그리고 Memory Base입니다. 그래서 Command 구조가 메모리 구조식으로 되어 있습니다. 물론 Physical로 나갈 떄는 Gen 1,2는  8b/10b, Gen3는 128b/130b 인코딩을 써서 시그널 구조로 갑니다.
- NVMe에서 쓰이는 Command들의 구조를 여기서 정의 합니다.

5,6 장은 실제 사용하는 Command에 대한 내용입니다.

7장은 Command 의 처리와 여러가지 기능등에 대한 상세 설명입니다.

8장도 여러가지 기능에 대한 내용입니다. 9장은 스킵!.



## NVMe와 PCIe의 관계

NVMe는 실제 Command 단위로 움직이는 Protocol Layer이고, 그 밑에 Transport, Link, Physcal (SATA  기준으로) Layer는 PCIe Spec.을 따릅니다. 그리고 보통 S/W 가 작업하는 F/W Level은 Protocol Layer 부분부터 가져오게 됩니다.

하기 그림에서 NVMe Protocol이 정의 하는 내용은 Software layer입니다. 그리고 그 밑단의 일련의 작업들은 실제로 PHY Chip이라 불리우는 H/W가 해줍니다. 그래서 NVMe Spec.의 2장은 System Bus (PCI Express) Registers라고 이름 붙여져 있습니다.

![Physical Layer](/assets/images/pcie.png)

PC에서 Power ON이 되면 Mainboard의 F/W인 BIOS에서 PCI Device를 인식합니다. 인식한 뒤에 Link Layer에서 Link 부분의 Negotation을 합니다. Link 초기화 후에 실제 PCI Device로 부터 PCI Header를 읽어 갑니다. 이 때부터 PCI Device인지 알게 됩니다. PCI Slot을 보통 그래픽 카드나 랜카드, 사운드 카드를 사용하시는데 많이 쓰셨을껀데, Device ID 중에 Mass Storage가 있습니다. Header 안에는 Device의 Vendor(회사명 입니다. PCI Sig 에 등록된 생산회사명), Device ID(PCI 에 붙은 장치의 종류 : 그래픽 카드라던가...), BAR, Expansion ROM Address 등등이 적혀 있고, 이 부분을 다 읽어가고 나면 이제 NVMe Device로서 인식을 하고 NVMe 명령어를 던지게 됩니다.

기본적으로 NVMe 명령어도 Transaction Layer로 내리면 PCIe로 감싸지기 때문에 위에서 바라볼때만 NVMe인거지 그 밑단에서는 PCIe와 다를게 없습니다. 그래서 NVMe를 심도 있게 보시려면 PCIe TLP(Transaction Layer Packets) 까지는 보셔야 제대로 보실수 있습니다.

또한, PCIe를 사용하는 만큼 커넥터 역시 여러가지를 쓰는데, PCIe Slot 이외에  M.2 또는 SFF8639가 있습니다. [참조](http://nvmexpress.org/wp-content/uploads/2013-FMS-NVMe-Track.pdf) 자료에 보면 NVMe 에서 어떻게 설명하고 있는지 나옵니다. 결국 PCIe를 사용하는 입장이기에 PCIe를 어느정도 알지 못하면 NVMe 자체를 잘 사용할수 없다가 결론입니다. (NVMe Spec. 2장을 공부하시다가 궁금하신건 PCIe Spec. 3.0을 참고하시기 바랍니다.)





# NVMe Base Spec. Rev. 1.4c 정리

## 1. Introduction

### **1.1 Overview**

NVMe interface는 host software가 non-volatile memory subsystem와 통신할 수 있도록 해준다.

NVMe는 PCIe interface를 사용하는 enterprise와 client SSD에 최적화되어 있다.

### **1.2 Scope**

해당 spec은 NVM subsystem의 controller와 register interface를 정의한다.

세 종류의 Controller가 존재한다.

1. I/O controllers
2. Discovery controllers
3. Administrative controllers

### 1.3 Outside of scope

### **1.4 Theory of Operation**

NVMe Interface는 최적화된 command submission과 completion paths를 제공한다.

Key attributes

- command submission 또는 completion path에서 uncacheable/MMIO register read가 필요하지 않다.
- command submmision path에서 최대 하나의 MMIO register wrtie가 필요하다.
- 최대 64K I/O queue 지원과 각 I/O queue는 64K개의 outstanding commands가 가능하다.
- 각 I/O queue와 관련된 priority는 well-defined arbitration mechanism으로 조정 된다.
- 4KB read 요청을 완료하기 위한 모든 정보는 64B command에 포함된다.
- 효율적이고 streamlined command set을 가진다.
- MSI / MSI-X와 interrupt 지원한다.
- Multiple namespaces 지원한다.
- SR-IOV처럼 효율적인 I/O virtualization을 지원한다.
- Robust error reporting과 management capabilities
- Multi path I/O와 namespace sharing을 지원한다.

NVMe controller는 single PCI function과 연관된다.

전체 controller에 적용되는 capabilities와 설정들은 Controller Capabilities (CAP) 레지스터와 Identify Controller data structure를 나타낸다.

하나의 namespace는 logical block으로 format된 non-volatile memory의 quantity이다.

NVMe controller는 namespace ID를 가지는 multiple namspaces를 지원한다.

Namspaces는 Namespace Management와 Namespace Attachment commands로 생성과 삭제가 된다.

Identify Namespace data structure는 특정 namespace의 capabilities와 설정을 나타낸다.

NVMe interface는 submission과 completion queue의 pair 형태를 기반으로 한다.

Commands는 host software에 의해 submission queue에 issue 된다.

Completions는 controller에 의해 completion queue에 issue 된다.

Multiple submiision queues는 동일한 completion queue를 이용한다.

Submission과 complition queues는 메모리에 할당 된다.

Admin submission과 이와 관련된 completion queeu는 controller 관리, I/O submission과 completion queues들의 생성과 삭제 및 aborting commands 등 control 목적을 위해 존재한다.

I/O command set은 I./O queue pair로 사용된다.

해당 spec에서는 I/O command set을 NVM command set으로 명시한다.

**Queue pair**

- Host software는 controller가 지원하는 최대 개수의 queue를 생성한다.
- queue 생성은 system configuration과 anticipated workload에 기반한다.
- queue 생성의 종류는 1:1 mapping, n:1 mapping이 존재 한다.

**Submission Queue와 Completion Queue를 이용한 I/O 처리 과정**

- Submission Queue (SQ)는 host software가 controller에 의해 실행되기 위한 commands를 전달하기 위한 고정된 크기의 circular buffer이다
- 실행되어야 할 1~n개의 새로운 commands이 있다면 host software는 적절한 SQ Tail doorbell 레지스터를 업데이트 한다. 
- 새로운 doorbell resister write가 있을때 이전의 SQ tail 값을 덮어 쓰기한다.
- Controller는 SQ entries을 SQ에서 순차적으로 fetch하고 어떤 순서로(알고리즘에 기반) 실행한다.
- 각 SQ entry는 command이고 64B의 크기를 가진다.
- 메모리내 Physical 메모리는 data 전송을 위해 사용되며, Phsical Region Page (PRP) entries 또는 Scatter Gather Lists가 나타낸다.
- 각 command는 두개의 PRP entires 또는 하나의 SGL segment를 포함한다.
- 만약 data buffer를 위해 두개 이상의 PRP entires가 필요하다면, PRP Lists의 pointer가 PRP entires를 가리킨다.
- 위와 동일하게 하나 이상의 SGL이 필요한 경우, SGL semgment는 다음 SGL segment pointer를 제공한다.
- Completion Queue (CQ)는 completed command의 상태를 나타내기 위한 고정된 크기의 circular buffer이다. 
- Completed command는 host software에서 할당된 SQ identifier와 comand identifier의 조합으로 식별된다.
- Multiple SQ는 하나의 CQ를 사용한다. 

**Multi-Path I/O and Namespace Sharing**

- Multi path I/O는 하나의 host와 하나의 namespace 사이간에 두개 이상의 독립된 path를 말한다.
- 반면에 namespace sharing은 두개이상의 host가 다른 NVM controller를 사용하는 shared namespace에 접근하는 것을 말한다. 

### **1.5 Conventions**

Abbreviations

- RO : Read Only
- RW : Read Write
- R/W : Read Write. The value read may not be the last value written.
- RWC : Read/Write '1' to clear
- RWS : Read/Write '1' to set
- Impl Spec : Implementation Spec
- HwInit : The default state is dependent on NVMe controller and system configuration
- Reset : This column indicates the value of the field after a reset

Use a '0's based value 

### **1.6 Definitions**

Admin queue

- identifier 0을 가지는 SQ와 CQ이다.
- administrative commnad를 submit하고 completions을 받기 위해 admin SQ와 admin CQ는 pair를 이룬다.

Administrative controller

- Host가 NVM subsystem을 관리할수 있도록 capabilities를 가지고 있는 controller
- 해당 controller는 I/O queues를 가지지 않는다.
- Logical blocks과 관련된 metadata 또는 data에 대한 접근을 제공한다.
- namespaces를 지원한다.

Arbitration burst

- Round robin 또는 weighted round robin을 사용하는 SQ로부터 한번에 처리 가능한 commands의 최대 수를 말한다.

Arbitration mechanism

- SQ에서 Controller에 의해 수행되기 위한 command를 결정하기 위해 사용 된다.

Cache

- NVM subsystem을 사용하는 data storage area

Command completion

- Controller가 command를 처리한 command
- 처리 결과 상태는 completion queue entry에 업데이트 된다.

Command submission

- Command는 SQ Tail doorbell write는 처리되었을때 submmit 된다. 

Controller

- Types
  - I/O controllers
  - Discovery controllers
  - Administrative controllers
- Controller는 host에 의해 SQ에 submmit된 commands를 실행하고 completion queue에 completion을 업로드 한다.
- 각 controller는 하나의 admin SQ와 하나의 admin CQ를 가진다.
- Controller에 따라 하나 이상의 I/O queues를 가질수 있다.

directive

- host와 NVM subsystem 또는 controller 정보를 교환하는 방법이다.
- 정보는 Directive Send와 Directive Receive commands를 통해 전달된다.
-  I/O commands의 subset은 I/O command와 관련된 정보를 통신하기 위해 Directive Type field와 Directive Specfic field를 포함한다.

Discovery controller

- Host가 Discovery Log Page 정보를 받을수 있도록 하는 특성을 가진 controller이다.
- I/O queues를 가지지 않는다. 

Emulated controller

- Software에 정의된 NVMe controller이다. 

Endurance Group

- NVM subsystem내 NVM 중 일부이다.
- Group 으로 endurance가 관리된다.

extended LBA

- 연속적인 LBA 전송과 관련된 memta가 전송될때 생성된다.

firmware slot

- NVM subsystem내에서 firmware image를 저장하기 위해 사용되는 슬롯이다. 
- NVM subsystem은 1~7개 firmware images를 저장할 수 있다.

I/O completion queue

- I/O completion queue는 completion queue이다. 
- 하나 이상의 SQ와 연관되며, I/O CQ identifiers는 64K까지 값을 가진다.

I/O submission queue

- I/O submission queue는 SQ이다. 
- Controller에 의해 실행하기 위한 I/O command를 SQ에 submit한다.

I/O controller

- I/O queues를 가지는 controller이다. 
- NVM storage를 접근하기 위해 사용된다.

LBA range

- 연속적인 logical blocks의 범위이다.

Logical block

- 가잔 작은 접근 가능한 data 단위이다.

Logical block address (LBA)

- Logical block의 주소이다.

metadata

- 특정 LBA 데이터에 대한 정보이다.

primary controller

- Virtualization Management command를 지원하는 NVMe controller이다.



## 2. System Bus (PCI Express) Registers

## **Ice Breaking PCIe interface (not included in spec)**

2장이 시작되기 전 PCI 및 PCIe에 대한 기본적 지식이 필요함을 느껴 진행 한다. 

참조 자료:

1. 1. [mindshare에서 나온 PCIe pdf](https://www.mindshare.com/files/ebooks/PCI Express System Architecture.pdf)
   2. [PCIe 관련 블로그1 - 문c 블로그 - PCI subsytem](http://jake.dothome.co.kr/pci-1/)
   3. [PCIe driver development for Exynos SoC by Samsung](http://kossa.kr/materials/LinuxForum/15 PCIe Driver Development for Exynos SoC.pdf)
   4. [Linux PCI drivers - Free Electrons](https://bootlin.com/doc/legacy/pci-drivers/pci-drivers.pdf)
   5. [Overview of PCIe subsystem - Texas Instruments](https://prezi.com/abwyjs_zofyg/overview-of-pcie-subsystem/)
   6. [PCI system architecture, Local Bus, Tutorial - Porto University](https://paginas.fe.up.pt/~ee00013/microPCI/materialGroup04.html)
   7. [PCIe 관련 블로그2](http://melonicedlatte.com/computerarchitecture/2019/11/26/184500.html)
   8. http://egloos.zum.com/nimphaplz/v/5314763
   9. https://wiki.qemu.org/images/f/f6/PCIvsPCIe.pdf
   10. https://pcisig.com/sites/default/files/files/PCI_Express_Basics_Background.pdf#page=26
   11. https://slidesplayer.org/slide/14669145/
   12. https://wiki.osdev.org/PCI
   13. https://static.lwn.net/images/pdf/LDD3/ch12.pdf
   14. https://wiki.qemu.org/images/f/f6/PCIvsPCIe.pdf

### **Peripheral Component Interconnect Bus (\**PCI\**)**

**위키백과**
PCI 버스는 컴퓨터 메인보드에 주변 장치를 장착하는 데 쓰이는 컴퓨터 버스의 일종이다.
이 장치는 다음과 같이 두 가지 형태로 나뉜다.
 \1. 주기판 위에 바로 붙는 IC 형태 - PCI 스펙에서는 이러한 형태를 평면 장치(planar device)라고 부른다.
 \2. 소켓에 꽂아 쓰는 확장 카드 형태 - 사용자 입장에서 흔히 눈에 띄는 형태이다.내가 본 PCI의 경우 2번의 형태가 많았다. 주로 sound card, ethernet card 등을 꽂아 사용한다.

### **PCI 특징**

PCI는 이전의 ISA, MCA, EISA, VESA 버스를 대체하기 위해 설계 되었다. 

PCI는 아래의 특징을 가진다.

1. 1. 1. 빠른 전송 속도
         - 기존 bus들은 낮은 clock cycle (ISA: 4.7MHz, MCA: 10MHz, EISA: 8.3MHz, VESA: 33MHz)을 가진다.
         - PCI는 33MHz부터 266MHz 이상의 clock cycle을 가져 데이터의 빠른 전송이 가능하다.
      2. 단일화된 인터페이스
         - CPU와 PCI bus 사이에 system/PCI bus bridge를 설치해 여러 프로세서를 위한 설계가 가능하다.
         - PCI bus에 PCI/Expansion bus bridge를 설치해 기존의 버스를 사용할 수 있다.
      3. 동시에 여러개의 function을 지원 
         - 같은 PCI bus상에 여러 bus master가 존재할 수 있다.
         - 하나의 디바이스에 동시에 여러개의 function을 지원할 수 있다. 

### **PCI Express (PCIe)**

**위키백과**
PCIe는 앞서 언급한 버스 표준들과 비교하여 높은 시스템 버스 대역폭, 적은 I/O 핀 수, 적은 물리적 면적, 버스 장치들에게 더 뛰어난 성능 확장성, 상세한 오류 검출 및 보고 구조(Advanced Error Reporting (AER), 핫-플러그 기능등 여러 장점을 가지고 있다. 최근에는 하드웨어 I/O 가상화도 지원한다\

### **PCIe 특징**

PCIe는 기본적으로 PCI가 가지는 성능적 한계 및 신호 왜곡 등을 개선하기 위해 기존의 병렬 bus로 구성된 PCI의 bus를 serial bus로 바꿔 설계했다. PCIe는 PCI 슬롯을 그대로 사용하며 여러개의 슬롯을 공유하지 않고 1:1로 연결해 사용한다. 따라서, 여러 장치를 붙일 경우 PCIe switch를 사용해 다수의 End device를 연결할 수 있도록 한다.

PCIe의 장점은 아래와 같다.

1. Bandwidth의 증가
2. Bus clock cycle의 증가
3. Bus width의 감소
4. 회로의 단순화
5. PCI 디바이스 SW 호환성 유지

기본적으로 PCI는 병렬 bus를 이용하기 때문에 신호 왜곡에 취약하기 대문에 bus의 clock cycle을 올리기 어렵다. 이를 dual-simplex 방식의 serial bus로 바꿈으로써 bus width의 감소, clock cycle의 증가, 회로의 단순화 등의 장점을 가진다.

([참조: http://www.technoa.co.kr/news/articleView.html?idxno=38092)](http://www.technoa.co.kr/news/articleView.html?idxno=38092)

### **PCIe Lane**

**Link**

x1 ~ x32 lane을 하나로 묶어 사용할 수 있다. 

1개의 Lane은 TX와 RX로 dual-simplex 구성으로 되어 있으며, 1개의link는 End-to-End Device간 1:1로 통신이 가능하다.



![img](https://blog.kakaocdn.net/dn/dbKdRt/btqAYHrLLJq/o7XaF0ULsqSjVD9PhDGLT0/img.png)Lane과 Link 구분



**Dual-simplex**

단 방향으로의 데이터 bus가 2개 1개 set로 구성되어, 하나의 bus는 데이터를 보내고 다른 하나의 bus는 데이터를 받는 것에만 사용된다. PCIe는 기본적으로 2개의 데이터 전달 통로(lane)을 갖는다. 

*Full duplex도 존재 한다. 여러가지 방법이 존재 함.



![img](https://blog.kakaocdn.net/dn/bBHtfV/btqA05rEVyR/D2cCzgNvBk5ChISu01pTsK/img.jpg)Dual-simplex



### ***\*PCIe Topology\****



![img](https://blog.kakaocdn.net/dn/t29Kr/btqA2a0lPJx/KVITsXMGz8NGH3XRalhFH0/img.png)PCIe topology architecture



위 그림은 PCIe를 통해 데이터를 전송하고자 하는 architecture의 topology를 나타낸다.

PCIe로 port를 연결하기 위해서는 기본적으로 Root Complex (RC)가 필요하다. 

RC는 CPU와 PCIe bus들 사이의 interface를 말하며 CPU interface, DRAM interface 등 여러가지 구성요소와 여러 개의 칩들을 포함한다. RC의 위치는 CPU내 ([구글링 검색 결과](https://www.quora.com/Does-the-motherboard-of-a-computer-act-as-the-PCIe-root-complex)), 메인보드 Chipset 내에 존재 한다.

전체 fabric의 instance들은 다음 구성요소이다.

1. 1. Root Complex
   2. Multiple endpoints (I/O devices)
   3. Switch
   4. PCIe to PCI/PCI-X bridge



![img](https://blog.kakaocdn.net/dn/K8bow/btqAXoGxotb/9AzUeUE9KjfOLEV8Mcqwm0/img.jpg)PCIe switch를 통한 PCIe 확장 port



Switch의 경우 위 그림 처럼 PCIe slot을 여러개 확장해서 사용할수 있도록 한다.

### **PCIe Root Complex (RC)**



![img](https://blog.kakaocdn.net/dn/VoMmQ/btqA2aF3q3K/w7SGjHFXknXiDgMH2euvK0/img.png)Root Complex 구조



RC는 Host CPU와 연결하기 위한 host bridge device와 secondary device 연결을 위한 PCIe port가 존재 한다. 

### **Switch**



![img](https://blog.kakaocdn.net/dn/bfkWpe/btqA06xpjyP/ZKZpQ7i9DJu352O0INzet0/img.jpg)Switch 구조



1. 1. Switch는 하나의 RC에 여러 디바이스를 붙일 수 있도록 만든 장치이다.
   2. Swtich는 여러개의 Down-stream ports를 가지고 있지만 up-stream port는 하나만 존재 한다. 
   3. 모든 활성화된 switch port는 flow control을 지원해야 한다. (Packet router처럼 동작하며, 해당 packet의 주소와 다른 routing 정보를 통해 어떤 경로로 packet이 가야하는지 인식한다.)

### **Endpoint Device**

1. 1. Endpoint device는 아래의 3가지 종류가 존재한다.
   2. Legacy PCI endpoint
      - Type 0 configuration header를 제공하는 function이여야 함
      - I/O 요청 제공 및 발생 가능
      - 4GB (32bit 주소 register일때) 주소를 초과하는 memory transaction 불가
      - MSI/MSI-X를 지원
   3. PCIe Endpoint
      - Type 0 configuration space를 제공하는 function이여야 함
      - I/O 요청 불가
      - 4GB 주소 범위를 넘는 memory transaction 가능 (64bit addressing 가능)
      - MSI/MSI-X 지원
   4. Root Complex integrated endpoint
      - Type 0 configuration space를 제공하는 function이여야 함
      - Root complex 내부 로직에 구현된 root port
      - I/O 요청 불가
      - 전원 관리 구현 X
      - Hot plug 지원 X
      - MSI/MSI-X 지원
      - [**32bit BAR를 통해 memory resource를 지원 (End-point device의 BAR와 비교한 결과 존재)**](https://blog.naver.com/PostView.nhn?blogId=joa_quin&logNo=221511458504&parentCategoryNo=&categoryNo=19&viewDate=&isShowPopularPosts=true&from=search)

### **PCIe 계층 구조 및 데이터 전송**



![img](https://blog.kakaocdn.net/dn/vc0tH/btqA05kUSZ9/q2EiAmlnVQoHWJaznGHHU1/img.jpg)PCIe 5개 Layer



PCI 전송에는 3개(Transaction layer, Data link layer, Physical layer)의 layer가 필요하다. 

PCI -> PCIe 변화 (paralle bus -> serial bus)로 변경되는 부분은 Transaction, Data Link, Physical 계층이다.



![img](https://blog.kakaocdn.net/dn/6pN5q/btqA05eb8L7/5qDCiDorNraXLsG7sQJob1/img.jpg)Packet의 생성과 Data의 전달



 

아래는 데이터의 전송 과정을 요약했다.

1. 1. Transaction layer에서는 packet 단위의 전송을 위해 데이터 packet을 형성하고 이를 Link layer로 전달한다.
   2. Link layer에서 데이터의 신뢰도를 위한 CRC 코드를 전달 받은 데이터에 삽입한다.
   3. Physical layer에서 frame 붙여 데이터를 추가 후 8b/10b 인코딩을 해 데이터를 전송하기 위해 serialized data로 변환한다.



![img](https://blog.kakaocdn.net/dn/bCy9lv/btqAXQireZD/3PgCX4oO7Ml2a0izzwT4k0/img.jpg)



 

Transaction layer에서 생성된 데이터 packet은 header와 data로 구성되어 있다. 해당 packet이 Data link layer로 전달되고 Data link layer에서 packet의 순서를 정한 번호와 CRC코드가 앞뒤로 붙게 된다. 그리고 Physical layer로 도착한 데이터에 대해 앞뒤로 frame을 붙이고 해당 packet을 serialize하며 이때 8b/10b 인코딩 시키면 PCIe bus를 통해 데이터를 전달하게 된다. 하지만 이것은 PCIe Gen 1 기준으로 나타냈다. Gen 3만 보더라도 encoding scheme이 128b/130b로 늘어났기 때문이다. 전송되는 packet의 구성과 크기는 아래와 같다.



![img](https://blog.kakaocdn.net/dn/TcoBJ/btqA2brpMp7/sBYHrL4LPlZxCPI8fGBl8k/img.png)전달되는 packet의 구성



1. 1. Physical Layer
      - Framing
        - Start (1B)
        - End (1B)
   2. Data Link Layer
      - Sequence Number (2B)
      - LCRC (1DW)
   3.  Transaction Layer
      - Header (3~4DW)
      - Data (0~1024DW)
      - ECRC (1DW)

### **Transaction Layer**

Ttransaction layer에 발생되는 packet을 Transaction Layer Packets (TLP)라 부른다. TLP는 routing mechanism 및 규칙에 따라 하나의 링크에서 다른 링크로 전달된다. 아래는 TLP가 접근하는 4개의 address spcae를 말한다. 즉, PCIe 디바이스에서 packets이 전달될때 아래의 분리된 주소 공간이 사용된다. (TLP header를 통해 구분한다)

1. 1. Memory
      - Transaction types: Read, Write 
      - Purpose: transfter data to or from a location in the system memory map
   2. I/O
      - Transaction types: Read, Write
      - Purpose: Transfer data to or from a location in the system IO map
   3. Configuration
      - Transaction types: Read, Write
      - Purpose: Transfer data to or from a location in the configuration space of a PIC-compatible device
   4. Message
      - Transaction types: baseline, vendor-specific
      - Purpose: general in-band messaging and even reporting without consuming memory or IO address resoures



![img](https://blog.kakaocdn.net/dn/xyJxD/btqA2bEYzsb/jmKkJF0Vf5DBpBkPBTU7bK/img.png)TLP Header



 

### **Data Link Layer**

- 링크 트레이닝
  - 링크 폭
  - 링크 데이터 rate
  - Lane reversal (Lane 역 방향 순서 지원)
  - Polarity inversion (극성 반대 지원)
  - 멀티 레인에서 레인 to 레인 de‐skew
- 전원 관리
  - 트랜잭션 게층에서 요청한 전원 상태를 수락하고 물리 계층으로 전달한다.
  - 활성/재설정/연결 해제/전원 관리 상태를 트랜잭션 계층으로 전달한다.
- 데이터 프로텍션, 에러 체킹
  - CRC 생성
  - 에러 체킹
  - 재전송 메시리지대한 TLP 응답
  - 에러 리포팅 및 로깅을 위한 에러 인디케이션

### **Physical Layer**

- 인터페이스 초기화, 메인트넌스 제어 및 스테이터스 트래킹
  - 리셋/핫플러그 컨트롤
  - 전원 관리 인터커넥트
  - width & lane 매핑 협상
  - lane 극성 반전
- 심볼 및 오더
  - 8b/10b 엔코딩 및 디코딩
  - 임베디드 클럭 튜닝 및 정렬
- 심볼 전송 및 정렬
  - 전송 회로
  - 리셉션 회로
  - 수신 측 Elastic 버퍼
  - 수신 측 멀티 lane de-skew



--------------------------------------------------------------------------------------------------------------------------------------------------------



PCI 버스에는 여러가지 장치가 물리는데 그 장치를 사용하려면, 각 장치가 어떤 것이고(identification), 어떻게 장치와 통신해야 하는지(protocol)를 알아야 한다. PCI 버스에서는 장치를 인식하고, 그 장치의 기본적인 정보를 얻어오기 위해 configuration space를 사용한다. 각 장치에 대해 할당된 configuration space를 통해 파악하게 되며 Device ID,Vendor ID,Status,Class code 등의 정보들이 해당 주소 공간에 저장되어 있다. 



![img](https://blog.kakaocdn.net/dn/cig5wM/btqBcLgkMnm/CuPwkE5pauf4T85FZaYxe1/img.png)PCI configuration space header



디바이스의 PCI configuration space 정보를 읽으면 디바이스와 통신을 하기 위한 기본적인 정보를 알 수 있다. PCI slot에 연결된 장치치에 대한 configuration space는 집적으로 읽을수 없다. 즉, OS가 부팅하면서 PCI에 연결된 모든 디바이스를 검색 해야 한다. 이때, PCI디바이스는 물리적으로 모든 디바이스에 **bus, device, function** 이라는 번호가 부여된다. 이 번호는 PCI slot에 따라 부여되는 것이기 때문에, 모든 bus, 모든 device, 모든 function을 스캔 해 보면, 컴퓨터에 달린 모든 디바이스 정보를 알 수 있다. 이 과정을 **enumeration**이라 한다





![img](https://blog.kakaocdn.net/dn/OeFky/btqBdUX96wV/6kvhB0SZxLZl4o37lsfQX1/img.png)PCI enumeration 과정



계속 공부를 진행하며 bus, device, function의 차이에 대해 궁금해졌다. 우리가 사용하는 PC에서 PCI slot에 장치를 연결한다면 해당 장치는 모두 다른 bus번호로 연결되는 것인지 등 어떤 디바이스들이 같은 bus를 공유하는지에 대해 궁금했다.



![img](https://blog.kakaocdn.net/dn/GyBSW/btqBc56JqY3/3kQBYE9j9PvgcQnvMCLdrK/img.png)



### **PCI address**

**Configuration Address Space**

- 'Configuration Address Space’ has been defined to support PCI hardware configuration
- 'Configuration Address Space’ provides access to 256 bytes of special configuration registers per PCI device.
- PCI Express introduces 'Extended Configuration Space‘ which extends the Configuration Space to 4096 bytes per Function
- ‘Configuration Read’ command and ‘Configuration Write’ command are used to transfer data between each ‘Configuration Address Space’ of PCI devices

**Memory Address Space**

- ‘Memory address space’ is used for burst transactions
- Two different address formats are used: 32-bit address format and 64-bit address format
- ‘Memory Read’ command and ‘Memory Write’ command are used to transfer data in ‘Memory Address Space’

**I/O Address Space**

- ‘I/O address space’ is for compatibility with the x86 architecture's I/O port address space. Future revisions of PCI Express specification may deprecate the use of ‘I/O Address Space’
- ‘I/O Read’ command and ‘I/O Write’ command are used to transfer data in ‘I/O Address Space’.

**Configuration Address Space**

- PCI devices have a set of registers referred to as 'Configuration Space‘
- This configuration space is used for auto configuration of inserted PCI cards
- Configuration Space registers are mapped to memory locations
- PCI framework S/W should access the configuration space.



--------------------------------------------------------------------------------------------------------------------------------------------------------



NVMe Spec 2장에서는 어떻게 PCI header, PCI capabilities, PCIe extended capabilites가 NVMe controller에 대해 구성되어 있는지를 살펴 본다.



![img](https://blog.kakaocdn.net/dn/dWALFd/btqBeSl0SuP/gNDNHTEhPPIaQKmxqKNVO1/img.png)PCIe registers



PCIe register에 대한 큰 틀에서의 구성이다. SSD 내에 존재하는 controller의 PCIe와 관련된 IP의 register들에 대한 설정이다. PCI header는 0x00 ~ 0x3F까지 범위이며, 뒤의 register들은 펌웨어에서 메모리 어느 부분에 베이스 주소를 가지고 갈 것인지에 따라 다르게 설정될수 있다.

가장 먼저 PCI header에 대해 살펴 볼 것이다.

### **PCI Header**

PCI header는 디바이스의 타입에 따라 Type 0, Type 1 두 종류로 나뉘며 Type에 따라 header의 bit가 다르게 사용된다. 하지만, 여기에서는 RC 혹은 Bridge를 사용한 디바이스가 아닌 RC에 다이렉트로 연결된 End device를 가정으로 설명한다. 

- Type 0 header: PCI Express 디바이스
- Type 1 header: Switch 및 Root Complex 가상 PCI Bridges



![img](https://blog.kakaocdn.net/dn/dG3ybM/btqBfraG5O4/PkYz3gtv58fKIKOsfxUBM0/img.png)Type 0 header

![img](https://blog.kakaocdn.net/dn/buMS1F/btqBeTk0eP3/4bu8wfHeCWvRV5OTRw8Dk0/img.png)PCI header 설명



그리고 PCI header에 대해 spec을 그냥 읽는 것 보다는 하나의 디바이스를 예제로 보는 것이 좋기 때문에 아래처럼 실행하자. 

```
$ lspci -x
```

 



![img](https://blog.kakaocdn.net/dn/xUCpj/btqBdVcGGFj/zK0vDpCBBsVzbTRrfVG9W0/img.png)$ lspci --help 결과



PCI slot에 연결된 디바이스들에 대해 정보를 알기 위해선 리눅스에서 lspci 명령을 통해 알수 있다. Configuration address 중 PCI header 부분에 대해서만 알고 싶다면 -x 옵션을 전체 4KB에 대한 영역 전부 알고 싶다면 -xxx 옵션을 주면 된다. 아래는 Virutual box에서 가상으로 생성한 NVMe device의 결과이다. 



![img](https://blog.kakaocdn.net/dn/5fPSr/btqBgEf4uTJ/xoR6vfbpiNavoPL0TzQG41/img.png)$ lspci -x 결과

![img](https://blog.kakaocdn.net/dn/qvw4n/btqBfr9zREL/JHZjB3fXH4SHeuZsX8iB8K/img.png)



- ID - identifiers
  - ID 값에 대한 비트 필드를 나타낸다. 
  - vendor ID와 devie ID 두개의 필드를 가진다.
  - vendor ID: 80ee
  - devcie ID: 4e56
  - 삼성 디바이스의 경우 144d의 vendor ID를 가지게 된다. 
  - vendor ID list를 보고 싶으면 [여기](https://pci-ids.ucw.cz/read/PC?restrict=)를 들어가면 볼 수 있다.

![img](https://k.kakaocdn.net/dn/cDwtkC/btqBfsAEJIA/RUGkaTD2f6FzUvLGz3PDfK/img.png)

- CMD - command
  - 2B의 값을 가진다. 
  - 값: 0x0007
  - Enable 
    - I/O space enable
    - Memory space enable
    - bus master enable
  - device로 하여금 I/O space와 memory space 영역에 접근을 가능하도록 한다. 
  - bus master로 동작하기 때문에 위의 영역을 통해 데이터 전송을 할 수 있다. (어떤 데이터를 주고 받는 것일까?)



![img](https://blog.kakaocdn.net/dn/bsCU4a/btqBgDIhriQ/Wl6fPQQN8EAFY5d7ESXws1/img.png)



- STS - device status
  - 2B의 값을 가진다.
  - 값: 0x0010
  - Enable
    - capabilites list
  - capabilities list가 존재 함을 나타낸다. 



![img](https://blog.kakaocdn.net/dn/kYquN/btqBdUZb0J1/FJlNYZVIw1kjP2LdNWoD61/img.png)



- RID - revision ID
  - 1B의 값을 가진다.
  - 값: 0x00
  - controller의 수정 버전을 나타내는 것 같다. (확실치 않음, 내가 본 5대의 SSD는 모두 0의 값을 가짐)



![img](https://blog.kakaocdn.net/dn/cexyRM/btqBeAGcZZM/9fx3YtFLodpGrTM4hWxqI1/img.png)



- CC - class code
  - 3B의 값을 가진다.
  - 값: 0X010802
  - Programming interface : 0x02, 즉 I/O controller가 있음을 나타낸다.
  - sub class code : 0x08
  - base class code: 0x01
  - PCI의 class 분류를 볼려면 [여기](https://blog.ladsai.com/pci-configuration-space-class-code.html)를 누르면 된다.
  - 대 분류, 중분류라고 생각 하면 될거 같다. mass storage 중에서도 플로피 디스크, IDE 등 다양한 storage들이 존재하는데 그 중에서 sub class code가 0x08이므로 non-volatile memory를 나타낸다. 



![img](https://blog.kakaocdn.net/dn/b27ioN/btqBeyO7xZ1/xHeaSOK5zCXX5TKcbja8e0/img.png)



- CLS - cache line size
  - 1B의 값을 가진다. 
  - 현재 여기에서는 0의 값을 가져 cache 가 없는 것으로 확인 되지만, 실제 SSD중 일부 제품의 경우 해당 크기가 정해져있는 것으로 확인 되었다. 



![img](https://blog.kakaocdn.net/dn/blRnlf/btqBeS7souX/XCdSIY8ikNCQz5kvslhmz0/img.png)



- MLT - master latency timer
  - 1B의 값을 가진다. 
  - 값: 0X40



![img](https://blog.kakaocdn.net/dn/c8l6hT/btqBgDVOKPF/h8lFM6C9IRC7nKDJute0Z0/img.png)



- HTYPE - header type
  - 1B의 값을 가진다. 
  - 여기에서는 두개의 필드 모두 0의 값을 가진다. 하지만, NVM subsyetem에서 multi function을 지원하는 경우 해당 7번 bit는 set된다.



![img](https://blog.kakaocdn.net/dn/Tbhvm/btqBg7WDsIG/f4kKQXmB5uGzmm3VoFu3ok/img.png)



- BIST - build in self test
  - 1B의 값을 가진다.
  - 모두 0의 값을 가진다. BIST를 지원하지 않는다. 



![img](https://blog.kakaocdn.net/dn/0Qepg/btqBc5fyBwy/YsdrB8n9fVXtCki3cuxSvK/img.png)



- MLBAR - memory register base address
  - 4B의 값을 가진다.
  - 값: 0xf0808000



![img](https://blog.kakaocdn.net/dn/2CKrw/btqBgD2ywIO/J8oMSK4MJ5rZJlv1lF2u51/img.png)



- MUBAR - memory register base address
  - MLBAR의 base address와 합쳐서 최대 64bit의 base address 주소 공간을 가질 수 있다. 



![img](https://blog.kakaocdn.net/dn/qrpa6/btqBgFswr94/5df0rBM0aSa6KzuFAkcPIk/img.png)



- BAR2 - index/data pair register base address
  - 4B의 값을 가진다.
  - 값: 0x0000d271



![img](https://blog.kakaocdn.net/dn/bgw4aE/btqBgEUG0BO/TugzslK4mWg8wd3oxlgRP1/img.png)



- CCPTR - cardbus cis pointer
  - 지원 안함



## 3. Controller Registers 

Controller register는 2장 내용중 PCI header 부분에서 나온 MLBAR/MUBAR (PCI BAR0, BAR1) register들을 통해 Host PC의 main memory 영역에 할당되어 있다. Host는 locked access를 할수 없다. 아래의 그림은 SSD controller에서 사용될 register들에 대한 정의이다. 



![img](https://blog.kakaocdn.net/dn/69Jbf/btqBg73pdCy/1AUYlbSCEwLjCcKaLvAppk/img.png)



```
nvme-cli가 설치되어 있다는 전제하에 실행
#nvme show-regs /dev/nvme0
또는
#nvme show-regs /dev/nvme0 -H
```

2장에서처럼 마찬가지로 이번에는 controller의 register 값들을 보기 위해[ nvme-cli](https://github.com/linux-nvme/nvme-cli) 툴을 사용한다. nvme-cli는 nvme 디바이스에 대해 편리하게 사용하기 위한 commnad line 기반의 management tool이다.



![img](https://blog.kakaocdn.net/dn/bGH6ad/btqBdT62JOc/TS1yuLyfqI5zMOcRkE3PHK/img.png)# nvme show-regs --help 결과



nvme show-regs /dev/nvme0만 사용했을 경우엔 hex 값으로 값이 전부 보이며 -H 옵션을 주게 되면 human-readable 옵션으로 보기 좋게 바뀐다. 



![img](https://blog.kakaocdn.net/dn/5pZw2/btqBdUETSXa/ign0OklpNaqctk9CXVGqJ1/img.png)# nvme show-regs /dev/nvme0 결과

![img](https://blog.kakaocdn.net/dn/AsdXj/btqBg9toeHB/jNimkBcFKOXzK2sgrH5SqK/img.png)# nvme show-regs /dev/nvme0 -H 결과



```
cap     : 200a010fff
	Controller Memory Buffer Supported (CMBS): The Controller Memory Buffer is Not Supported
	Persistent Memory Region Supported (PMRS): The Persistent Memory Region is Not Supported
	Memory Page Size Maximum	   (MPSMAX): 4096 bytes
	Memory Page Size Minimum         (MPSMIN): 4096 bytes
	Boot Partition Support              (BPS): No
	Command Sets Supported              (CSS): NVM command set is supported
	NVM Subsystem Reset Supported     (NSSRS): No
	Doorbell Stride                   (DSTRD): 4 bytes
	Timeout                              (TO): 5000 ms
	Arbitration Mechanism Supported     (AMS): Weighted Round Robin with Urgent Priority Class is not supported
	Contiguous Queues Required	      (CQR): Yes
	Maximum Queue Entries Supported    (MQES): 4096

version : 10200
	NVMe specification 1.2

cc      : 460001
	I/O Completion Queue Entry Size (IOCQES): 16 bytes
	I/O Submission Queue Entry Size (IOSQES): 64 bytes
	Shutdown Notification              (SHN): No notification; no effect
	Arbitration Mechanism Selected     (AMS): Round Robin
	Memory Page Size                   (MPS): 4096 bytes
	I/O Command Sets Selected          (CSS): NVM Command Set
	Enable                              (EN): Yes

csts    : 1
	Processing Paused               (PP): No
	NVM Subsystem Reset Occurred (NSSRO): No
	Shutdown Status               (SHST): Normal operation (no shutdown has been requested)
	Controller Fatal Status        (CFS): False
	Ready                          (RDY): Yes

nssr    : 0
	NVM Subsystem Reset Control (NSSRC): 0

intms   : 0
	Interrupt Vector Mask Set (IVMS): 0

intmc   : 0
	Interrupt Vector Mask Clear (IVMC): 0

aqa     : 1f001f
	Admin Completion Queue Size (ACQS): 32
	Admin Submission Queue Size (ASQS): 32

asq     : 303d9000
	Admin Submission Queue Base (ASQB): 303d9000

acq     : 34580000
	Admin Completion Queue Base (ACQB): 34580000

cmbloc  : 3
	Offset                                                        (OFST): 0x0 (See cmbsz.szu for granularity)
	CMB Queue Dword Alignment                                     (CQDA): 0
	CMB Data Metadata Mixed Memory Support                      (CDMMMS): Enforced
	CMB Data Pointer and Command Independent Locations Support (CDPCILS): Enforced
	CMB Data Pointer Mixed Locations Support                    (CDPMLS): Enforced
	CMB Queue Physically Discontiguous Support                   (CQPDS): Enforced
	CMB Queue Mixed Memory Support                               (CQMMS): Enforced
	Base Indicator Register                                        (BIR): 0x3

cmbsz   : 500003
	Size                      (SZ): 1280
	Size Units               (SZU): 4 KB
	Write Data Support       (WDS): Write Data and metadata transfer in Controller Memory Buffer is Not supported
	Read Data Support        (RDS): Read Data and metadata transfer in Controller Memory Buffer is Not supported
	PRP SGL List Support   (LISTS): PRP/SG Lists in Controller Memory Buffer is Not supported
	Completion Queue Support (CQS): Admin and I/O Completion Queues in Controller Memory Buffer is Supported
	Submission Queue Support (SQS): Admin and I/O Submission Queues in Controller Memory Buffer is Supported

bpinfo  : ffffffff
	Active Boot Partition ID      (ABPID): 1
	Boot Read Status                (BRS): Error completing Boot Partition read
	Boot Partition Size            (BPSZ): 32767
bprsel  : ffffffff
	Boot Partition Identifier      (BPID): 1
	Boot Partition Read Offset    (BPROF): fffff
	Boot Partition Read Size      (BPRSZ): 3ff
bpmbl   : ffffffffffffffff
	Boot Partition Memory Buffer Base Address (BMBBA): ffffffffffffffff
cmbmsc	: ffffffffffffffff
	Controller Base Address (CBA)	     : fffffffffffff
	Controller Memory Space Enable (CMSE): 1
	Capabilities Registers Enabled (CRE) : CMBLOC and CMBSZ registers are enabled

cmbsts	: ffffffff
	Controller Base Address Invalid (CBAI): 1

pmrcap  : ffffffff
	Controller Memory Space Supported (CMSS)		   : Referencing PMR with host supplied addresses is Supported
	Persistent Memory Region Timeout		    (PMRTO): ff
	Persistent Memory Region Write Barrier Mechanisms(PMRWBM): f
	Persistent Memory Region Time Units		    (PMRTU): PMR time unit is minutes
	Base Indicator Register			      (BIR): 7
	Write Data Support				      (WDS): Write data to the PMR is supported
	Read Data Support				      (RDS): Read data from the PMR is supported
pmrctl  : ffffffff
	Enable (EN): PMR is READY
pmrsts  : ffffffff
	Controller Base Address Invalid (CBAI): 1
	Health Status			  (HSTS): Reserved
	Not Ready			  (NRDY): The Persistent Memory Region is Not Ready to process PCI Express memory read and write requests
	Error				  (ERR) : ff
pmrebs  : ffffffff
	PMR Elasticity Buffer Size Base  (PMRWBZ): ffffff
	Read Bypass Behavior			   : memory reads not conflicting with memory writes in the PMR Elasticity Buffer SHALL bypass those memory writes
	PMR Elasticity Buffer Size Units (PMRSZU): Reserved
pmrswtp : ffffffff
	PMR Sustained Write Throughput       (PMRSWTV): ffffff
	PMR Sustained Write Throughput Units (PMRSWTU): Reserved/second
pmrmsc	: ffffffffffffffff
	Controller Base Address (CBA)		: fffffffffffff
	Controller Memory Space Enable (CMSE	: 0
```

 위 결과는 -H 옵션을 주고 실행했을때의 결과이다. 



![img](https://blog.kakaocdn.net/dn/bOKbd9/btqBdTTx6If/rWEkx6JHymsDjyAoweHSuK/img.png)



- CAP -controller capabilities
  - 8B의 크기를 가지고 있다.
  - 값: 0x200a010fff
  - controller의 특성을 host software에게 알려준다. 
  - nvme-cli에서는 admin passthru command를 통해 register 값을 읽어 온다.
  - Controller Memory Buffer Supported (CMBS): The Controller Memory Buffer is Not Supported 
  - Persistent Memory Region Supported (PMRS): The Persistent Memory Region is Not Supported 
  - Memory Page Size Maximum   (MPSMAX): 4096 bytes
  - Memory Page Size Minimum     (MPSMIN): 4096 bytes
  - Boot Partition Support       (BPS): No
  - Command Sets Supported       (CSS): NVM command set is supported
  - NVM Subsystem Reset Supported   (NSSRS): No
  - Doorbell Stride          (DSTRD): 4 bytes
  - Timeout               (TO): 5000 ms
  - Arbitration Mechanism Supported   (AMS): Weighted Round Robin with Urgent Priority Class is not supported
  - Contiguous Queues Required    (CQR): Yes
  - Maximum Queue Entries Supported  (MQES): 4096 



![img](https://blog.kakaocdn.net/dn/c5yeGQ/btqBf4fgyGc/lOZ4tSZnOlD56AVGPdw7h0/img.png)nvme-cli show-regs의 마지막 전달 과정

![img](https://blog.kakaocdn.net/dn/ETNhd/btqBgE8fGHT/qti6hZvmgjxjt1A2N1kWd1/img.png)



- VS - version에 대한 것을 나타냄. 1.0 ~ 1.4까지 존재함. 
  - 4B를 가진다.
  - 값: 0x10200
  - NVMe specification 1.2



![img](https://blog.kakaocdn.net/dn/dUJC18/btqBeJQrkTh/AnvrZZSewfA2U5s72TiLT1/img.png)



- intms - interrupt mask set 
  - 4B를 가진다.
  - 값: 0 Interrupt Vector Mask Set (IVMS): 0 



![img](https://blog.kakaocdn.net/dn/p90BW/btqBeyPabFK/xKLQlce4PCvp8QtcJv40z1/img.png)



- intmc - interrupt mask clear
  - 4B를 가진다.
  - 값: 0 Interrupt Vector Mask Clear (IVMC): 0



![img](https://blog.kakaocdn.net/dn/tvbjA/btqBeJCUYTu/ZF6wquttxCy3IU2FxW1At0/img.png)



- CC - controller configuration
  - 해당 register는 controller를 위한 셋팅을 변경한다.
  - Host가 가능한 부분
    - Arbitraction mechanism (CC.AMS)
    - Memory page size (CC.MPS)
    - Command set (CC.CSS)
  - cc   : 460001
  - I/O Completion Queue Entry Size (IOCQES): 16 bytes
  - I/O Submission Queue Entry Size (IOSQES): 64 bytes
  - Shutdown Notification       (SHN): No notification; no effect
  - Arbitration Mechanism Selected   (AMS): Round Robin
  - Memory Page Size          (MPS): 4096 bytes
  - I/O Command Sets Selected     (CSS): NVM Command Set
    - controller가 diable되었을대 (CC.EN == 0) 설정을 변경할 수 있다.
  - Enable               (EN): Yes 



![img](https://blog.kakaocdn.net/dn/cfHZdW/btqBg889EKE/YR5SiQkKP4VSIgeFXHVlrk/img.png)



- NSSR - NVM subsystem reset
  - NVM Subsystem Reset Control (NSSRC): 0
  - CAP.NSSRS와 관련



![img](https://blog.kakaocdn.net/dn/G59FB/btqBf2Iylab/ukaxnGjOjJo7i6tQTQZo5k/img.png)



- AQA - admin queue attributes
  - 값: 1f001f 
  - Admin Completion Queue Size (ACQS): 32
  - Admin Submission Queue Size (ASQS): 32 



![img](https://blog.kakaocdn.net/dn/V2lVF/btqBezN4VTL/DdMzrKk719uGbObwiDqim1/img.png)

![img](https://blog.kakaocdn.net/dn/cwH3Z1/btqBeKaLGst/9YhzKpvK5RihUd5EpKkeZk/img.png)



- asq   : 303d9000
  - Admin Submission Queue Base (ASQB): 303d9000
- acq   : 34580000
  - Admin Completion Queue Base (ACQB): 34580000



![img](https://blog.kakaocdn.net/dn/c5GwWp/btqBgeaVzAJ/dXU68VSxdeqXnpGDQTnrHK/img.png)



cmbloc : 3
Offset                            (OFST): 0x0
CMB Queue Dword Alignment                   (CQDA): 0
CMB Data Metadata Mixed Memory Support           (CDMMMS): Enforced
CMB Data Pointer and Command Independent Locations Support (CDPCILS): Enforced
CMB Data Pointer Mixed Locations Support          (CDPMLS): Enforced
CMB Queue Physically Discontiguous Support          (CQPDS): Enforced
CMB Queue Mixed Memory Support                (CQMMS): Enforced
Base Indicator Register                    (BIR): 0x3



![img](https://blog.kakaocdn.net/dn/Kfexi/btqBf2u1fqg/qj9E82WcxFm0ewngDrkc6K/img.png)



cmbsz  : 500003
Size           (SZ): 1280
Size Units        (SZU): 4 KB
Write Data Support    (WDS): Write Data and metadata transfer in Controller Memory Buffer is Not supported
Read Data Support    (RDS): Read Data and metadata transfer in Controller Memory Buffer is Not supported
PRP SGL List Support  (LISTS): PRP/SG Lists in Controller Memory Buffer is Not supported
Completion Queue Support (CQS): Admin and I/O Completion Queues in Controller Memory Buffer is Supported
Submission Queue Support (SQS): Admin and I/O Submission Queues in Controller Memory Buffer is Supported



![img](https://blog.kakaocdn.net/dn/tlXmq/btqBge9ObEa/gfSsyP0S9Wq3rWhOdk3sc1/img.png)



bpinfo : ffffffff
Active Boot Partition ID   (ABPID): 1
Boot Read Status        (BRS): Error completing Boot Partition read
Boot Partition Size      (BPSZ): 32767



![img](https://blog.kakaocdn.net/dn/bv4L40/btqBc57Jygu/YYMk5e87FsSQoVAdKdS6o1/img.png)



bprsel : ffffffff
Boot Partition Identifier   (BPID): 1
Boot Partition Read Offset  (BPROF): fffff
Boot Partition Read Size   (BPRSZ): 3ff



![img](https://blog.kakaocdn.net/dn/bkGhKW/btqBc6lmEuW/xcw0e686paA0lM7uLQVWFK/img.png)



bpmbl  : ffffffffffffffff
Boot Partition Memory Buffer Base Address (BMBBA): ffffffffffffffff



![img](https://blog.kakaocdn.net/dn/oUPpI/btqBf22RLZg/3toM4Y3bdkON2kxLU7PdG1/img.png)



cmbmsc : ffffffffffffffff
Controller Base Address (CBA)    : fffffffffffff
Controller Memory Space Enable (CMSE): 1
Capabilities Registers Enabled (CRE) : CMBLOC and CMBSZ registers are enabled



![img](https://blog.kakaocdn.net/dn/b8NORI/btqBc5fBDYK/WazDOqt29VO5mInaVyHkR0/img.png)



cmbsts : ffffffff
Controller Base Address Invalid (CBAI): 1



![img](https://blog.kakaocdn.net/dn/eQ5i4W/btqBgD9mNqP/DQKzLBFk4RR5oJUrNflCH0/img.png)



pmrcap : ffffffff
Controller Memory Space Supported (CMSS)   : Referencing PMR with host supplied addresses is Supported
Persistent Memory Region Timeout   (PMRTO): ff
Persistent Memory Region Write Barrier Mechanisms(PMRWBM): f
Persistent Memory Region Time Units   (PMRTU): PMR time unit is minutes
Base Indicator Register    (BIR): 7
Write Data Support    (WDS): Write data to the PMR is supported
Read Data Support    (RDS): Read data from the PMR is supported



![img](https://blog.kakaocdn.net/dn/cFvagX/btqBeJXcERd/ggEYOFavWbTPXJQvZO7Ke1/img.png)



pmrctl : ffffffff
Enable (EN): PMR is READY



![img](https://blog.kakaocdn.net/dn/IcRLe/btqBeS7vJmp/k3DFqlKG22FvIANYwkEGgk/img.png)



pmrsts : ffffffff
Controller Base Address Invalid (CBAI): 1
Health Status  (HSTS): Reserved
Not Ready  (NRDY): The Persistent Memory Region is Not Ready to process PCI Express memory read and write requests



![img](https://blog.kakaocdn.net/dn/mYrbS/btqBc48VIFR/rAKWsUs4fRSSopfhYXuj70/img.png)



pmrebs : ffffffff
PMR Elasticity Buffer Size Base (PMRWBZ): ffffff
Read Bypass Behavior   : memory reads not conflicting with memory writes in the PMR Elasticity Buffer SHALL bypass those memory writes
PMR Elasticity Buffer Size Units (PMRSZU): Reserved



![img](https://blog.kakaocdn.net/dn/Bbc6C/btqBgEtG4nl/aVmnfbQHgdyUmC3FTVMfJK/img.png)



pmrswtp : ffffffff
PMR Sustained Write Throughput    (PMRSWTV): ffffff
PMR Sustained Write Throughput Units (PMRSWTU): Reserved/second



![img](https://blog.kakaocdn.net/dn/bWy1Ud/btqBg8gZpuB/1n4kkBXsH1av96Hcd5LtNK/img.png)



pmrmsc : ffffffffffffffff
Controller Base Address (CBA) : fffffffffffff
Controller Memory Space Enable (CMSE : 0



![img](https://blog.kakaocdn.net/dn/bfmH89/btqBeSTUMtN/qEpWsK3BOI2QIq64CwGHX0/img.png)

![img](https://blog.kakaocdn.net/dn/cs2tY8/btqBeLAPtc0/I5aZ7DbzrlbhXqbgelDXuK/img.png)



## 4. Data Structures 

### 4.1 Submission Queue & Completion Queue Definition

해당 장에서 얘기되는 SQ와 CQ는 NVMe over PCIe에서만 적용이 된다. NVMe over Fabrics에 관한 SQ와 CQ의 정보는 NVMe over Fabrics spec을 참조해야 한다.

SQ와 CQ는 circular queue 구조를 가지며, head와 tail을 가지고 있어 entry point를 나타낸다. 



![img](https://blog.kakaocdn.net/dn/dx43lF/btqB6XNIPD9/rzcz7R1vxwOr7eZ1ZFxYsK/img.png)



submiiter는 현재 tail entry pointer가 가리키는 queue slot에 command를 저장한 후 tail pointer를 증가시킨다.

consumer는 현재 head entry pointer가 가리키는 slot를 가지고 간 후 head pointer를 증가시킨다.

Queue Empty 상태
• Head == Tail
Queue Full 상태
• Head == Tail + 1 mod # Of Queue Entries.

 

SQ와 CQ의 생성과 삭제는 host software에 의해 요청되어져야 한다.

생성시 CQ가 생성된 이후에 관련된 SQ가 생성된다. 삭제시 SQ가 먼저 메모리 해제된 이후 CQ가 삭제된다.

 



![img](https://blog.kakaocdn.net/dn/bOw66y/btqB5EH5kSG/WabObjIq5DLgeXDVlWQoRK/img.png)



Host software는 새로운 command가 entry로 들어왔다는 것을 통신하기 위해 SQ tail doorbell과 CQ head doorbell에 쓰기를 수행한다. 만약 SQ tail doorbell 또는 CQ head head doorbell에 invalid value 쓰기와 asyn 이벤트 요청 command가 처리되지 않았다면, admin CQ에 invalid doorbell write value status가 놓여지게된다. 문제를 해결 하기 위해 host software에 의해 queue가 삭제 및 재생성되며, controller는 이전에 처리 중이던 command까지만 끝내고 추가적인 command에 대해서 처리하지 않는다. 해당 상황은 host software가 full 상태인 SQ에 entry를 추가하거나 빈 CQ에서 entry를 가지고 갈려는 동작에서 비롯된다.

 

Host software는 새로운 CQ entry가 놓여졌는지 확인하기 위해 CQ entry의 Phage Tag (P) bit를 확인한다. CQ tail pointer는 host에서는 알지 못하고 controller 내부에서만 사용된다. controller는 CQ 항목의 SQHD (SQ Head Pointer) 필드를 사용하여 SQHD의 새 값을 호스트에 전달한다. 

 

Queue identifier: 16 bit ID 값으로 queue가 생성되었을때 할당된다. 이것으로 queue를 식별하게된다.

 

### 4.2 Submission Queue Entry - Command Format

SQ는 64byte 크기로 구성되어 있다. 하지만, 추후에 spec에 의해서 command format이 변경될수 있다.

(NVMe spec 1.2와 비교해 Dword 0의 15번 bit만 사용되던 것이 spec 1.4에선 [15:14] bit로 확장되었다. 



![img](https://blog.kakaocdn.net/dn/bQUcTq/btqB6IcdTkq/o4XBenG0KHV0tRoqhsmM70/img.png)



**Dword 0**

\- [07:00] opcode: 실행하기 위한 command의 opcode를 명시한다.

\- [09:08] Fused Operation (FUSE): 간단한 command 두개를 같이 수행하는 command로 만든다. 두개의 command사이에는 어떤 command도 존재하지 않으며, atomic 하게 수행된다.



![img](https://blog.kakaocdn.net/dn/d71LIt/btqB797JiGj/M9ZKIlZ5BKVg74hQIYcx31/img.png)



\- [15:14] PRP or SGL for Data Transfer (PSDT): command와 관련된 data를 전송함에 있어 PRPs 또는 SGLs 중 어느 것을 선택할 것인지에 대한 field이다. PRPs는 NVMe over PCIe에서 admin commands를 위해 사용된다. SGLs는 NVMe over Fabrics에서 Admin command 그리고 I/O command를 위해 사용된다. 



![img](https://blog.kakaocdn.net/dn/D6Vcw/btqB797Jnhf/7IsmKucDgFnjN93yqCMqQ0/img.png)



\- [31:16] Command Identifier (CID): SQ identifier와 함께 조합되어 고유의 identifier를 나타낸다.

 

**Dword 1**

\- [31:00] Namespace Identifier (NSID): command가 적용되는 namespace를 나타낸다. 만약 command에 NSID 값이 사용되지 않는다면 0x0의 값을 가진다. 만약 0xFFFFFFFF의 값을 가진다면 broadcast value(모든 네임 스페이스를 지정하는 데 사용되는 값)이다. 만약 비활성화된(생성은 되었지만 controller에 deattached된 상태) NSID 값을 사용한다면 contoller는 abort 를 status Invalid Field를 남기고 수행한다. invalid NSID 값을 사용한다면 controller는 status Invalid Namespace or Format를 남기고 abort를 수행한다. broadcast value가 지원되지 않는 command 종류에 broadcast value를사용했다면 controller는 status Invalid Field를 남기고 abort를 수행한다.

 

**Dword 4, 5**

\- [63:00] Metadata Pointer (MPTR): MPTR은 logical block data과 interleaved되지 않은 metadata가 command에 있을시에 유효하게 사용된다.

Dword 0의 PSDT field가 0b00인 경우, MPTR field는 metadata의 연속된 physical buffer 주소를 나타낸다. MPTR의 [01:00] 비트가 0b00의 값을 가지지 않는다면, controller는 invalid field 에러를 리포트한다. 

Dword 0의 PSDT field가 0b01인 경우, metadata의 phyiscal buffer 주소를 포함한다. 

Dword 0의 PSDT field가 0b10인 경우, 한개의 SGL descriptor를 포함하는 SGL segment 주소를 포함한다. SGL segment내에 포함된 SGL descriptor는 command를 위한 metadata의 첫번째 SGL descriptor를 나타낸다. 

 

**Dword 6~9**

\- [127:000] Data Pointer (DPTR): command에 포함된 data를 나타낸다. 

Dword 0의 PSDT field가 0b00인 경우, PRP entry 1과 PRP entry2를 나타낸다. 

PRP1: command를 위한 PRP entry 혹은 command와 연관된 PRP list pointer를 나타낸다.

PRP2: 
\1) memory page boundary를 초과하는 않는 data 전송의 경우 사용되지 않는다.

\2) 전송할 데이터가 하나의 memory page boundary를 초과하는 경우 두번째 memory page의 page base address를 나타낸다. 



![img](https://blog.kakaocdn.net/dn/enOAIV/btqB5g1L8ib/X5Qal7gwuYqwKQXFFf2imk/img.png)



\3) 전송할 데이터가 하나의 memory page boundary를 초과하고 두개 이상의 memory pages를 가져야 하는 경우 PRP list pointer를 나타낸다. 



![img](https://blog.kakaocdn.net/dn/c0YsOs/btqB5FG1hsR/5vfG5hIYqNABWsp7cnq2w0/img.png)



Dword 0의 PSDT field가 0b01 또는 0b10인 경우, SGL entry 1(SGL1)으로 사용된다.

Command를 위한 첫번째 SGL segment를 나타낸다. 



![img](https://blog.kakaocdn.net/dn/mevub/btqB6jcH47k/tRWgHexBO6V3BoCUZlwxsK/img.png)



### 4.3 Physical Region Page Entry and List

PRP (Physical region page) entry는 pysical memory page를 가리키는 pointer이다. PRPs는 controller와 memory 사이에 데이터 전송을 위한 scatter/gather mechanism을 사용한다. 효율적인 out of order의 순서로 data를 전송하기 위해 entry는 고정된 사이즈로 사용된다. Pysical memory page는 host software에 의해 CC.MPS에 설정된다. 



![img](https://blog.kakaocdn.net/dn/Jw4H5/btqB5FG1r3P/Y83N53xaVYjMMesBJpnS2k/img.png)



위 그림은 PRP entry의 64bit field를 나타낸다. offset은 CC.MPS에 의해 결정된다. 

[64:00] Page Base Address and Offset (PBAO): 4KB의 memory page size라면 [11:00] 12bit(2^12=4KB)가 offset으로 사용된다. 만약 첫번재 PRP entry나 PRP list pointer가 아니라면, offset은 0의 값을 가진다. dword로 align되므로 [01:00] 하위 2bit (2^2=4B)는 0b00의 값으로 된다. 만약 0b00으로 초기화 되지 않으면 PRP Offset Invalid 에러를 controller가 리포트 후 0b00으로 클리어 시킨다. 



![img](https://blog.kakaocdn.net/dn/bl6bcc/btqB8aevbBs/F99kzIbIuekS5m8Qp2WcqK/img.png)



PRP List (pysical region page list)는 연속적인 메모리의 single page를 가지는 PRP entry들의 집합이다. 만약 전송해야 할 data가 PRP list pages가 필요하다면 마지막 PRP entry는 다음 PRP list의 pointer를 가리킨다. 만약 non-zero offset을 PRP entry들이 가진다면 PRP offset invalid 에러를 반환한다. 

PRP list는 다음의 수식으로 entry의 개수를 포함하게 된다.

참조:https://lwn.net/Articles/804369/

```
#define PRP_SIZE			sizeof(__le64)
#define PRP_PER_PAGE		(PAGE_SIZE / PRP_SIZE)
```

PRP_SIZE는 64bit(8B)이고, PAGE_SIZE는 host page size를 default로 보통 4KB로 고려했을때 하나의 memory page안에 총 512개의 entry가 포함될수 있다. (4096B / 8B = 512개) 또한, 하나의 entry가 physical memory page (4KB)를 가리키므로 2048KB (2MB)의 데이터를 전송할 수 있게된다. 

### 4.4 Scatter Gather List (SGL)

우선 Scatter Gatehr의 의미를 파악하자.

커널 영역에서 메모리 관리를 할 때는 어렵긴 하지만(오버헤드가 크지만) 물리 메모리에 일렬로 정렬해서 사용하는 것이 가능하지만 사용자 영역에서는 이렇게 할 수가 없다. 커널 영역에서 메모리를 물리 영역에 일렬로 정리해서 쓰는것이 가능하다고 했지만 여기 저기 흩어져 있는(Scatter) 메모리를 일렬로 정렬되어 있는 것처럼 사용할 수 있다면 좀더 편한 관리가 가능할 것이다. 다시 정리하면 Scatter/Gather 의 개념은 여기 저기 흩어져 있는 메모리(Scatter) 를 논리적으로 모아서(Gather) 연속된 물리적 메모리처럼 사용하는 것을 의미하며 Scatterlist 는 여기 저기 흩어져 있는 메모리(Scatter) 의 모음(array) 라고 보면 된다.
출처: https://poplinux.tistory.com/75

```
struct scatterlist{
  struct page *page;
  unsigned int offset;
  dma_addr_t dma_address;
  unsigned int length;
}
```



![img](https://blog.kakaocdn.net/dn/Y9aEW/btqB7OW6MMV/KZCuwoeQfIIF10okhPE3vk/img.png)



왜 NVMe over PCIe에서는 SGL을 안쓰고 PRP를 쓰는지에 대한 이유이다. 결론은 결국 PRP가 SGL보다 간단하다이다. 하지만, 많은 양의 데이터를 전송할땐 SGL을 사용하는 것이 더 빠르다고 한다.

http://everylwn.blogspot.com/2016/06/sglscatter-gather-list-support-in-nvme_2.html

 

SGL은 데이터 버퍼를 표현하기 위한 memory 주소 공간의 자료구조이다. controller는 'Identify Controller data stucture'에 지원하는 SGL types를 가리킨다. data buffer는 source buffer이거나 destination buffer이다. SGL은 하나 이상의 SGL segment를 포함하고 있다. SGL 내에 Data Block과 Bit Bucket descriptor의 총 길이가 전송할 logical block의 수와 같거나 초과할것이다. 마지막 SGL segment는 SGL segment descriptor 또는 SGL last segment descriptor를 포함하지 않는다. 



![img](https://blog.kakaocdn.net/dn/bE4E3N/btqB8P8Q7Od/6kkQ7he6kpkFnGYvWZrnpK/img.png)

![img](https://blog.kakaocdn.net/dn/y2QXY/btqB6JIVNf8/SC67LrdeORLYlUmGv7HSyK/img.png)



SGL segment는 하나 이상의 SGL descriptor를 가진다. 



![img](https://blog.kakaocdn.net/dn/cJyymv/btqB7cw9Jbl/57aYeSNRd8GcrlYkjJGdaK/img.png)



SGL descriptor의 format이다. 

15B: SGL identifier

[03:00] SGL descriptor sub type: 만약 reserved value이거나 unsupported value인 경우, descriptor는 SGL descriptor type error로 처리된다.



![img](https://blog.kakaocdn.net/dn/bKl4MG/btqB8nxVwg2/o8V1JPpBkX2nACkLr9pHF1/img.png)



[07:04] SGL descriptor type: 만약 reserved이거나 unsupported value인 경우 SGL descriptor는 SGL descriptor type error로 처리된다. 



![img](https://blog.kakaocdn.net/dn/bhRuYO/btqB6JPIFVw/dXMDkUt2Z6wKpYCPmnlLv1/img.png)

![img](https://blog.kakaocdn.net/dn/GysV6/btqB7brucQc/6thukos3Js2ZI1KVf4Pt6K/img.png)



**SGL data block descriptor인 경우**



![img](https://blog.kakaocdn.net/dn/cVZtlw/btqB8oczIFg/e3ugIVHVVUuhCMlkZDywB1/img.png)



[07:00] Address:

\- SGL descriptor sub type field가 0x0인 경우: address field는 data block의 64bit memory 시작 주소를 나타낸다. 

\- SGL descriptor sub type field가 0x1인 경우: 전송되어야 할 memory 주소의 offset을 나타낸다. 

[11:08] Length: data block의 B단위 길이를 나타낸다. 0x0인 경우 전송할 데이터가 존재하지 않는다. 

[15:15] SGL identifier:

\- [03:00] SGL descriptor sub type



![img](https://blog.kakaocdn.net/dn/bKl4MG/btqB8nxVwg2/o8V1JPpBkX2nACkLr9pHF1/img.png)



\- [07:04] SGL descriptor type: 0x0

 

**SGL bit bucket descriptor인 경우**



![img](https://blog.kakaocdn.net/dn/bCKXGC/btqB5FfYx0y/q78UySViXQonltw6bFH081/img.png)



[11:08] Length: discard되는 source data의 길이를 나타낸다. 만약 destination data buffer인 경우, controller에 의해 discard되는 source data의 길이를 말한다. 만약 source data buffer인 경우 0이다. 

[15:15] SGL identifier:

\- [03:00] SGL descriptor sub type



![img](https://blog.kakaocdn.net/dn/bKl4MG/btqB8nxVwg2/o8V1JPpBkX2nACkLr9pHF1/img.png)



\- [07:04] SGL descriptor type: 0x0

### 4.6 Completion Queue Entry

CQ의 entry는 최소 16B 크기를 가진다. 추후에 I/O coomand set의 사용에 따라 크기가 달라질 수 있다.



![img](https://blog.kakaocdn.net/dn/yT3V8/btqB6Ysr6Uo/FtzUO5JB2dSh3nVSpEkoj1/img.png)



**Dword 2**

[31:16] SQ identifier (SQID): issue된 command와 관련되어 SQ를 구분하기 위한 식별자로 사용된다.

[15:00] SQ Head Pointer (SQHD): command를 가지고온 SQ의 현재 SQ head pointer를 가리킨다. 어디까지 entry가 처리되었는지를 나타낸다.

 

**Dword 3**

[31:17] Status Field (SF): 처리 완료된 command의 상태를 나타낸다. 

\- no fatal or non-fatal error conditions 없이 성공적으로 끝났을 경우 0x0의 값을 가진다. 

\- [31] Do Not Retry (DNR): 

--- set to 1: 같은 command가 다시 submmit된 command는 fail된다. 

--- set to 0: 같은 command가 다시 submiit된 command는 성공한다. 

\- [30] More (M): 

---set to 1: Get log pag command를 통해 받은 에러 정보보다 더 많은 status 정보를 가지고 있다.

---set to 0: 추가적은 status 정보가 없다.

\- [29:28] Command Retry Delay (CRD):

--- set to 0: ?????????????

\- [27:25] Status Code Type (SCT): status code type of the completion queue entry

\- [24:17] Status Code (SC): status code identifying any error or status information

 

[16:16] Phase Tag (P): CQ entry가 새로운 entry인지 판단하는데 사용된다. CC.EN이 1의 값이 되기전 host software에 의해 0으로 초기화 된다. controller가 CQ에 처리 끝난 entry를 놓은경우, host software가 새로운 entry를 식별할수 있도록 controller는 P field를 invert시킨다.

[15:00] Command Identifier (CID): 처리 완료된 command의 식별자를 가리킨다. 해당 식별자는 host software에 의해 SQ에 command가 놓여질때 할당된다. SQ identifier와 Command identifier의 조합으로 command가 완료되었다는 것을 판단할 수 있다.

### 4.7 Controller Memory Buffer

CQ

