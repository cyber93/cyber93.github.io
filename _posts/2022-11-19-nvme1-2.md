---
title:  "NVMe Spec. Rev. 1.4c 이야기 #2"
excerpt: "NVMe Base Spec. Rev. 1.4c Chap 1"

toc: true
toc_sticky: true

categories:
  - NVMe
tags:
  - NVMe Spec
---

<br>

# NVMe Base Spec. Rev. 1.4c

## 1. Introduction

### **1.1 Overview**

NVMe™ 인터페이스를 통해 호스트 소프트웨어는 비휘발성 메모리 하위 시스템과 통신할 수 있습니다. 이 인터페이스는 엔터프라이즈 및 클라이언트 솔리드 스테이트 드라이브에 최적화되어 있으며 일반적으로 **PCI Express 인터페이스에 레지스터 수준의 인터페이스로 연결**됩니다.

참고: 개발 중에는 이 사양을 Enterprise NVMHCI라고 했습니다. 다만 완성 전에 NVM 익스프레스 베이스 사양으로 이름을 수정했다. 이 인터페이스는 클라이언트 및 엔터프라이즈 시스템 모두에서 사용하기 위한 것입니다.

```wiki
[From 2014년 Blog Post]

NVMe의 태생에 대한 풍문에 따르면, 인텔은 NOR Flash를 밀고 한참 NVM(Non Volatile Memory)에 관심을 가지고 있었다고 합니다.
그리고 NVM으로 이루어진 스토리지 디바이스를 위한 프로토콜을 제정하니 그게 NVMHCI라 불리우는 것이었죠.

한동한 묻혀 있다가 요즘 세태가 바뀌면서 다시 수면으로 올라왔어요. 
그 배경은 NAND 기반의 SSD의 속도가 이미 기존 프로토콜의 한계인(SATA 이야기입니다. 일반 PC 기준) 6Gbps를(6Gbps라고 해도 실제 이론상으로도 8b/10b Encoding을 생각하면 600MB/S) 넘어서자 더 높은 대역폭을 원하게 되었고 PCI Express를 이용하게 됩니다. 실제로 PC에서 Data 움직일때 쓰는 Interface가 무척이나 많지만 제일 빠른건 PCI Express 이니깐요. Gen1이 Lane당 2.5, Gen2가 5.0 그리고 Gen3가 8.0GB/s. 정말 말도 안되는 속도죠. 게다가 Lane이 16개까지 사용가능하니... 현재 MAX치는 상상을 초월 합니다.

여튼 급한대로 PCIe를 이용해서 SATA의 프로토콜을 이용하는 일이 생겼습니다. 갑자기 성능이 쑥쑥 올라갑니다. 단 태생적 한계라고 하는데... SATA라는게 실제 Serial ATA고 Media 기반의 HDD용 스펙으로 사용 되었기에 빠른 Physical Layer를 가지는 PCIe의 자원을 실제적으로 잘 활용하지 못하는 사태가 벌어집니다. 그래서 예전에 살짝 넣어 두었던 NVMHCI를 꺼내서 NAND와 결합시켜 NVMe(Non Volatile Memory Express)로 이름을 바꾸고 이제 슬슬 나오고 있는 실정입니다.
```

#### **1.1.1 NVMe™ over PCIe® and NVMe™ over Fabrics**

NVM Express 기본 사양 개정 1.4 및 이전 개정에서는 호스트 소프트웨어가 PCI Express(**NVMe™ over PCIe™**)를 통해 비휘발성 메모리 하위 시스템과 통신하기 위한 레지스터 수준 인터페이스를 정의했습니다.

**NVMe™ over Fabrics** 사양은 프로토콜 인터페이스와 다른 상호 연결(예: 이더넷, InfiniBand™, 파이버 채널)을 통해 작동할 수 있는 NVMe 인터페이스에 대한 관련 확장을 정의합니다. NVMe over Fabrics 사양에는 각 NVMe 전송에 대한 NVMe 전송 바인딩이 있습니다(해당 사양 내에서 또는 참조로).

이 사양에서 요구 사항/기능은 NVMe over Fabrics 구현 또는 특정 NVMe 전송 바인딩에 특화되어 문서화될 수 있습니다. 또한 기능에 대한 지원 요구 사항은 NVMe over PCIe와 NVMe over Fabrics 구현 간에 다를 수 있습니다.



### **1.2 Scope**

이 사양은 NVM 하위 시스템의 컨트롤러와 통신하기 위한 레지스터 인터페이스를 정의합니다. 또한 컨트롤러에서 지원할 수 있는 표준 명령 세트를 정의합니다.

서로 다른 기능을 가진 세 가지 유형의 컨트롤러가 있습니다.

1. I/O controllers
2. Discovery controllers
3. Administrative controllers 

이 문서에서는 특정 컨트롤러 유형을 열거하는 대신 컨트롤러 유형이 문맥에 맞게 결정될 수 있도록 일반 용어인 컨트롤러를 자주 사용합니다.



### 1.3 Outside of scope

(Skipped)



### **1.4 Theory of Operation**

NVMe Interface는 최적화된 command submission과 completion paths를 제공한다.

Key attributes

- command submission 또는 completion path에서 uncacheable/MMIO register read가 필요하지 않다.
- command submmision path에서 최대 하나의 MMIO register wrtie가 필요하다.
- 최대 64K I/O queue 지원과 각 I/O queue는 64K개의 outstanding commands가 가능하다.
- 각 I/O queue와 관련된 priority는 well-defined arbitration mechanism으로 조정 된다.
- 4KB read 요청을 완료하기 위한 모든 정보는 64B command에 포함된다.
- 효율적이고 streamlined command set을 가진다.
- MSI / MSI-X와 interrupt 지원한다.
- Multiple namespaces 지원한다.
- SR-IOV처럼 효율적인 I/O virtualization을 지원한다.
- Robust error reporting과 management capabilities
- Multi path I/O와 namespace sharing을 지원한다.

NVMe controller는 single PCI function과 연관된다.

전체 controller에 적용되는 capabilities와 설정들은 Controller Capabilities (CAP) 레지스터와 Identify Controller data structure를 나타낸다.

하나의 namespace는 logical block으로 format된 non-volatile memory의 quantity이다.

NVMe controller는 namespace ID를 가지는 multiple namspaces를 지원한다.

Namspaces는 Namespace Management와 Namespace Attachment commands로 생성과 삭제가 된다.

Identify Namespace data structure는 특정 namespace의 capabilities와 설정을 나타낸다.

NVMe interface는 submission과 completion queue의 pair 형태를 기반으로 한다.

Commands는 host software에 의해 submission queue에 issue 된다.

Completions는 controller에 의해 completion queue에 issue 된다.

Multiple submiision queues는 동일한 completion queue를 이용한다.

Submission과 complition queues는 메모리에 할당 된다.

Admin submission과 이와 관련된 completion queeu는 controller 관리, I/O submission과 completion queues들의 생성과 삭제 및 aborting commands 등 control 목적을 위해 존재한다.

I/O command set은 I./O queue pair로 사용된다.

해당 spec에서는 I/O command set을 NVM command set으로 명시한다.

**Queue pair**

- Host software는 controller가 지원하는 최대 개수의 queue를 생성한다.
- queue 생성은 system configuration과 anticipated workload에 기반한다.
- queue 생성의 종류는 1:1 mapping, n:1 mapping이 존재 한다.

**Submission Queue와 Completion Queue를 이용한 I/O 처리 과정**

- Submission Queue (SQ)는 host software가 controller에 의해 실행되기 위한 commands를 전달하기 위한 고정된 크기의 circular buffer이다
- 실행되어야 할 1~n개의 새로운 commands이 있다면 host software는 적절한 SQ Tail doorbell 레지스터를 업데이트 한다. 
- 새로운 doorbell resister write가 있을때 이전의 SQ tail 값을 덮어 쓰기한다.
- Controller는 SQ entries을 SQ에서 순차적으로 fetch하고 어떤 순서로(알고리즘에 기반) 실행한다.
- 각 SQ entry는 command이고 64B의 크기를 가진다.
- 메모리내 Physical 메모리는 data 전송을 위해 사용되며, Phsical Region Page (PRP) entries 또는 Scatter Gather Lists가 나타낸다.
- 각 command는 두개의 PRP entires 또는 하나의 SGL segment를 포함한다.
- 만약 data buffer를 위해 두개 이상의 PRP entires가 필요하다면, PRP Lists의 pointer가 PRP entires를 가리킨다.
- 위와 동일하게 하나 이상의 SGL이 필요한 경우, SGL semgment는 다음 SGL segment pointer를 제공한다.
- Completion Queue (CQ)는 completed command의 상태를 나타내기 위한 고정된 크기의 circular buffer이다. 
- Completed command는 host software에서 할당된 SQ identifier와 comand identifier의 조합으로 식별된다.
- Multiple SQ는 하나의 CQ를 사용한다. 

**Multi-Path I/O and Namespace Sharing**

- Multi path I/O는 하나의 host와 하나의 namespace 사이간에 두개 이상의 독립된 path를 말한다.
- 반면에 namespace sharing은 두개이상의 host가 다른 NVM controller를 사용하는 shared namespace에 접근하는 것을 말한다. 



### **1.5 Conventions**

Abbreviations

- RO : Read Only
- RW : Read Write
- R/W : Read Write. The value read may not be the last value written.
- RWC : Read/Write '1' to clear
- RWS : Read/Write '1' to set
- Impl Spec : Implementation Spec
- HwInit : The default state is dependent on NVMe controller and system configuration
- Reset : This column indicates the value of the field after a reset

Use a '0's based value 



### **1.6 Definitions**

Admin queue

- identifier 0을 가지는 SQ와 CQ이다.
- administrative commnad를 submit하고 completions을 받기 위해 admin SQ와 admin CQ는 pair를 이룬다.

Administrative controller

- Host가 NVM subsystem을 관리할수 있도록 capabilities를 가지고 있는 controller
- 해당 controller는 I/O queues를 가지지 않는다.
- Logical blocks과 관련된 metadata 또는 data에 대한 접근을 제공한다.
- namespaces를 지원한다.

Arbitration burst

- Round robin 또는 weighted round robin을 사용하는 SQ로부터 한번에 처리 가능한 commands의 최대 수를 말한다.

Arbitration mechanism

- SQ에서 Controller에 의해 수행되기 위한 command를 결정하기 위해 사용 된다.

Cache

- NVM subsystem을 사용하는 data storage area

Command completion

- Controller가 command를 처리한 command
- 처리 결과 상태는 completion queue entry에 업데이트 된다.

Command submission

- Command는 SQ Tail doorbell write는 처리되었을때 submmit 된다. 

Controller

- Types
  - I/O controllers
  - Discovery controllers
  - Administrative controllers
- Controller는 host에 의해 SQ에 submmit된 commands를 실행하고 completion queue에 completion을 업로드 한다.
- 각 controller는 하나의 admin SQ와 하나의 admin CQ를 가진다.
- Controller에 따라 하나 이상의 I/O queues를 가질수 있다.

directive

- host와 NVM subsystem 또는 controller 정보를 교환하는 방법이다.
- 정보는 Directive Send와 Directive Receive commands를 통해 전달된다.
-  I/O commands의 subset은 I/O command와 관련된 정보를 통신하기 위해 Directive Type field와 Directive Specfic field를 포함한다.

Discovery controller

- Host가 Discovery Log Page 정보를 받을수 있도록 하는 특성을 가진 controller이다.
- I/O queues를 가지지 않는다. 

Emulated controller

- Software에 정의된 NVMe controller이다. 

Endurance Group

- NVM subsystem내 NVM 중 일부이다.
- Group 으로 endurance가 관리된다.

extended LBA

- 연속적인 LBA 전송과 관련된 memta가 전송될때 생성된다.

firmware slot

- NVM subsystem내에서 firmware image를 저장하기 위해 사용되는 슬롯이다. 
- NVM subsystem은 1~7개 firmware images를 저장할 수 있다.

I/O completion queue

- I/O completion queue는 completion queue이다. 
- 하나 이상의 SQ와 연관되며, I/O CQ identifiers는 64K까지 값을 가진다.

I/O submission queue

- I/O submission queue는 SQ이다. 
- Controller에 의해 실행하기 위한 I/O command를 SQ에 submit한다.

I/O controller

- I/O queues를 가지는 controller이다. 
- NVM storage를 접근하기 위해 사용된다.

LBA range

- 연속적인 logical blocks의 범위이다.

Logical block

- 가잔 작은 접근 가능한 data 단위이다.

Logical block address (LBA)

- Logical block의 주소이다.

metadata

- 특정 LBA 데이터에 대한 정보이다.

primary controller

- Virtualization Management command를 지원하는 NVMe controller이다.

